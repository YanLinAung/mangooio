mangoo I/O Documentation
========================

[NOTE]
You are reading version {version} of the documentation.

== Overview

Development of mangoo I/O started in mid 2015 out of the interest on
how difficult it would be to create an intuitive, developer friendly,
full stack web framework in Java from scratch. After I had a fresh new breeze of
java development for the web with the https://www.playframework.com[Play
Framwork - Version 1], contributions to the
http://www.ninjaframework.org[Ninja Framework] and having seen a lot of
cumbersome "Enterprise" applications, I thought it was time for yet
another full stack java web framework.

For me, developing mangoo I/O will always be about having a developer friendly,
easy to understand web framework with a small learning curve for the Java ecosystem.

At its core, mangoo I/O is a classic MVC-Framework. The foundation of mangoo I/O is the very performant
http://undertow.io[Undertow] web server from JBoss. On top of that,
standard, production ready java libraries are used - no reinventing of the
wheel, no bytecode manipulation, no magic whatsoever. The main reason for using Undertow was, that
it is based on non-blocking I/O in the form of
http://xnio.jboss.org[XNIO]. And although Undertow does support the
servlet API, one is not bound to use it in any way, giving a java developer
the opportunity to work fully stateless.

mangoo I/O is highly inspired by the http://www.ninjaframework.org[Ninja
Web Framework]. Although the mangoo I/O core is a complete custom
implementation, a lot of the ideas and methodologies were re-used.

Here are some key features of mangoo I/O in a nutshell:

* Intuitive convention-over-configuration, making a java developer feel
at home from the start
* Highly scalable using a share-nothing stateless architecture
* Hot-Compiling development mode for high productivity
* Easy to use template engine
* Support for Web Sockets
* Simple and self-explaining form handling and validation
* Plain scheduling for recurring tasks
* Easy handling of JSON in- and output
* Built-in asset minification in development mode
* Flexible testing tools
* Simple Deployment and CI-Integration
* i18N Internationalization
* Easy eMail handling

One main focus of mangoo I/O was to have a good and well documented code
base. Therefore, mangoo I/O is constantly checked against
http://www.sonarqube.org[SonarQube] with a rule set of more than 600
quality rules.

=== Libraries

Here are some used libraries and their purpose in mangoo I/O.

* Maven - Dependency management, built-system, packaging
* Undertow - Web Server
* Google Guice - Dependency injection and caching
* Logback - Logging
* Freemarker - Template engine
* Quartz Scheduler - Scheduling
* Boon JSON - JSON parser
* And many more ...

=== Documentation versioning

This documentation always comes from the latest stable tag of the GitHub
repository. However, you can change the version of the documentation by
simple adding the version number to the URL. If you want, for example, the documentation of version
1.0.0 re-open this page with the following URL

-------------------------------------
https://mangoo.io/documentation/1.0.0
-------------------------------------

A note in the header will show you, which version of the
documentation you are reading.

== Getting started

=== Preconditions

mangoo I/O requires
http://www.oracle.com/technetwork/java/javase/downloads/index.html[Java]
(at least 1.8) and https://maven.apache.org[Maven] (at least 3.1.1).

==== Checking Java

To make sure that you have Java correctly installed use the following
command

[source,bash]
---------------------------------------------------------------
java -version
---------------------------------------------------------------

This should output the Java version information as follows

[source,bash]
---------------------------------------------------------------
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
---------------------------------------------------------------

==== Checking Maven

To make sure that you have Maven correctly installed use the following
command

[source,bash]
------------
mvn -version
------------

This should output the Maven version information as follows

[source,bash]
------------------------------------------------------------------------------
Apache Maven 3.3.3 (...)
Java version: 1.8.0_45, vendor: Oracle Corporation
Java home: /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home/jre
Default locale: de_DE, platform encoding: UTF-8
...
------------------------------------------------------------------------------

Now you are ready to create your first mangoo I/O application!

=== Creating your first mangoo I/O application

mangoo I/O comes with a ready-to-use Maven archetype, to get your first
application started in no time. To create your first application execute
the following Maven command:

------------------------------------------------------------------------------------------------------
mvn archetype:generate -DarchetypeGroupId=io.mangoo -DarchetypeArtifactId=mangooio-maven-archetype
------------------------------------------------------------------------------------------------------

You will be prompted for a group and artifact id. You also have to set an application name and an application secret.
Make your secret is "secure", as some functions, like sessions and authentication rely on it.
Once the archetpye generation is finished, change in your newly
created project directory and execute the following command:

[source,bash]
-----------------
mvn clean package
-----------------

Once the compilation is finished, you can start the development (dev) mode, by executing the following maven
command

[source,bash]
----------------
mvn mangooio:run
----------------

Once Maven has downloaded all required dependencies you should see the
mangoo I/O logo showing you that your new application has started
successfully in dev mode.

[source,bash]
---------------------------------------------------------------------------------------------------------
                                                ___     __  ___
 _ __ ___    __ _  _ __    __ _   ___    ___   |_ _|   / / / _ \
| '_ ` _ \  / _` || '_ \  / _` | / _ \  / _ \   | |   / / | | | |
| | | | | || (_| || | | || (_| || (_) || (_) |  | |  / /  | |_| |
|_| |_| |_| \__,_||_| |_| \__, | \___/  \___/  |___|/_/    \___/
                          |___/
https://mangoo.io | @mangoo_io | 1.0.0

mangoo I/O application started @127.0.0.1:8080 in 442 ms in dev mode. Enjoy.
---------------------------------------------------------------------------------------------------------

[NOTE]
Whenever you see the mangoo I/O logo your application has started successfully.

Now open your default web browser an say hello to your first mangoo I/O
application by opening the following URL

---------------------
http://localhost:8080
---------------------

[IMPORTANT]
.Using hot-compiling in dev mode
====
When in dev mode mangoo I/O supports hot-compiling. This means, that when you change a source file in your IDE
of choice the changes are available more or less instantly (in most cases in less than a second).
As mangoo I/O relies on Java 8, it is important that the files are compiled with the correct flags specific to Java 8.
To be more precise, mangoo I/O relies on the parameter flag that enables easy lookup of method parameters.

If you are using *Eclipse*, please make sure that you have checked the following option: +
Settings -> Compiler -> Check "Store information about method parameter (usable via reflection)"

If you are using *IntelliJ*, please make sure that you have checked the following option: +
Settings -> Java Compiler -> Add additional line parameters: -> "-parameters" (without the qoutes)

If you don't do this, mangoo I/O won't pass request parameters to your controller when in dev mode.

This is only required in dev mode, as compilation in all other modes is done via Maven
and the correct flags are set via the Maven compiler plugin.
====

=== Basic structure of a mangoo I/O application

If you have created a new mangoo I/O application via the maven archetype,
this is the basic structure of a the application

------------------------------------------------------------------------------------------------------
.
├── pom.xml
└── src
    └── main
        ├── java
        │   ├── conf
        │   │   ├── Lifecycle.java
        │   │   ├── Module.java
        │   │   └── Routes.java
        │   └── controllers
        │       └── ApplicationController.java
        └── resources
            ├── application.yaml
            ├── files
            ├── logback.prod.xml
            ├── logback.xml
            ├── templates
            │   ├── ApplicationController
            │   │   └── index.ftl
            │   └── layout.ftl
            └── translations
                ├── messages.properties
                ├── messages_de.properties
                └── messages_en.properties

------------------------------------------------------------------------------------------------------

mangoo I/O comes with the following convetion-over-configuration:

By convention the application must have a package src/main/java/conf with the
following classes

--------------
Lifecycle.java
Module.java
Routes.java
--------------

The Lifecycle class is used for hooking into the application startup process.
The Module class is used for your custom Google Guice bindings and the Routes
class contains you mapped request to controllers and methods, assets, etc.

The application must have a package src/main/resources with the
following files and folders

----------------
/files
/templates
/translations
application.yaml
logback.xml
----------------

The /files folder contains all static files (e.g. robots.txt or JS/CSS
assets) - see <<Handling static files and assets>> for more
information on serving static files and assets. The /templates folder contains all templates
of your application. By convention the /templates folder has a
layout.ftl file which contains the basic layout of your application.
Each controller class must have a (case-sensitive) corresponding
sub-folder inside the /templates folder, where the method name of each
controller must equal the template name, ending with a .ftl suffix. If you
are not rendering any template from your controller (e.g. if you are just sending JSON),
than this is of course optional.

The /translations folder contains all translation files of your
application. Each file starts with "messages", followed by a "_"  and the language
and a .properties suffix. Even if you have no translations in your
application, by convention there has to be at least a
messages.properties file in your /translations folder. Even if this file is empty.

It is recommended to have the controllers in a controller package, but not required
as the mapping is done in the Routes class and mangoo I/O doesn't require this.

If you don't provide a logback.xml file, then logback
will fallback to a default configuration provided with the logback base package.

== Configuration

mangoo I/O relies on one configuration file for your hole application.
The application.yaml file is located in the src/main/resources folder,
along with all other files, that are not Java classes. You can add and
customize settings, simply by adding an appropriate value in the
application.yaml, for example

[source,yaml]
------------------------
application:
      name   : myValue
------------------------

The application.yaml uses https://de.wikipedia.org/wiki/YAML[YAML] for setting
the configuration values.

There is a number of default properties which configure a mangoo I/O
application. See <<Configuration options>>,
for all configuration options and there default values.

Config values are accessed with a dot-notation in mangoo I/O. If you have
a config value like

[source,yaml]
------------------------
application:
      minify:
           js    : true
           css   : true
------------------------

this would be accessible by the following keys

------------------------
application.minify.js
application.minify.css
------------------------

To access a configuration value, first inject the Config class.

------------------------
@Inject
private Config config;
------------------------

You can access a configuration value, either by a given key or predfined defaults
from mangoo I/O.

------------------------
config.getString("application.minify.js");
config.getString(Key.APPLICATION_MINIFY_JS);
------------------------

=== Modes

By convention, mangoo I/O offers three configuration modes: **dev**,
*test* and **prod**. The dev mode is automatically activated, when you
start your mangoo I/O application for development with Maven for local development

[source,bash]
----------------
mvn mangooio:run
----------------

The test mode is automatically activated when executing unit test and using the
mangoo I/O test utilities. The prod mode is activated by default when no
other mode is given. You can overwrite this programatically, by setting a system property

[source,java]
----------------------------------------------
System.setProperty("application.mode", "dev");
----------------------------------------------

or by passing a system property to the executable JAR

[source,bash]
--------------------------
... -Dapplication.mode=dev
--------------------------

=== Mode configuration

You can create mode specific configuration by prefxing a configuration
value.

[source,yaml]
---------------------------------
default:
    application:
        host       : localhost
        port       : 8080

test:
    application:
        port       : 10808

dev:
    application:
        port       : 2342

---------------------------------

If no mode specific configuration is available, mangoo I/O will look up
the default value. If mangoo I/O can find a non-prefixed value it
will overwrite the default value.

By convention all default values are for the prod mode and will be overwritten, when
a mode specific value is found. This keeps the configuration values to a minimum.

== Lifecycle

In some cases it is useful to hook into the startup process of a mangoo
I/O application (e.g. for starting a database connection). For this cases
mangoo I/O offers the Lifecycle class, which can be found in the /conf
package of your application. Here is an example of how the Lifecycle
class may look like.

[source,java]
---------------------------------------------------
package conf;

import com.google.inject.Singleton;

import io.mangoo.interfaces.MangooLifecycle;

@Singleton
public class Lifecycle implements MangooLifecycle {

    @Override
    public void applicationInitialized() {
        // Do nothing for now
    }

    @Override
    public void applicationStarted() {
        // Do nothing for now
    }
}
---------------------------------------------------

[NOTE]
The Lifecycle class doesn't have to be named
"Lifecycle", but the class must implement the MangooLifecycle interface and
you have to bind the implementation using Google Guice in your Module
class. The module class is also located in the /conf package in your
application. This class can also hold other custom Google Guice bindings.

[source,java]
--------------------------------------------------------
package conf;

import io.mangoo.interfaces.MangooAuthenticator;
import io.mangoo.interfaces.MangooRequestFilter;
import io.mangoo.interfaces.MangooLifecycle;

import com.google.inject.AbstractModule;
import com.google.inject.Singleton;

import filters.MyGlobalFilter;

@Singleton
public class Module extends AbstractModule {
    @Override
    protected void configure() {
        bind(MangooLifecycle.class).to(Lifecycle.class);
    }
}
--------------------------------------------------------

== Routing

One of the main pieces of a mangoo I/O application is the mapping of
requests URLs to controllers classes and their methods. Whether you are rendering a
template, sending JSON or just sending a HTTP OK, every request has to
be mapped. This mapping is done in the Routes.java class, which you'll
find in the /conf package of your application. Request mappings can be done
in a fluent way by using the static Router class.

[source,java]
-------------------------------------------------------------------------------------------------
Router.mapRequest(Methods.GET).toUrl("/").onClassAndMethod(ApplicationController.class, "index");
-------------------------------------------------------------------------------------------------

This example maps a GET request to "/" to the index
method in the ApplicationController class. Thus, when you open your
browser and open the "/" URL the index method in the
ApplicationController class will be called.

[NOTE]
The Routes class has to implement the MangooRoutes interface to work properly.

=== Controllers

Every controller method, whether it renders a template, sends JSON or
just returns a HTTP Status, must return a Response object. This is handled by
using the Response class of mangoo I/O. Here is an example of how a
controller method may look like.

[source,java]
-----------------------------
public Response index() {
    return Response.withOk();
}
-----------------------------

By convention mangoo I/O will lookup a template name index.ftl in the following way

-------------------------------------------------------
/src/main/resources/templates/CONTROLLER_NAME/index.ftl
-------------------------------------------------------

With the previously mapped request, a request to "/" will render the
index.ftl template and send the template along with a HTTP Status OK to
the client.

=== Request and query parameter

mangoo I/O makes it very easy to handle request or query parameter. Lets
imagine you have the following mapping in your Routes class.

[source,java]
----------------------------------------------------------------------------------------------------------
Router.mapRequest(Methods.GET).toUrl("/user/{id}").onClassAndMethod(ApplicationController.class, "index");
----------------------------------------------------------------------------------------------------------

Note the {id} in the URL, that defines that this part of the URL is a
request parameter.

Now lets imagine you execute the following request

---------------
/user/1?foo=bar
---------------

For this example we are also added a query parameter.

To access both the request and query parameter, you can
simply add the names of the parameters along with the data type to your
controller method

[source,java]
-------------------------------------------
public Response index(int id, String foo) {
    //Do somethin useful with id and foo
    return Response.withOk();
}
-------------------------------------------

The following method parameters are available in mangoo I/O controller methods by default and can
be used as a request or query parameter.

-------------------------------------------
String
Integer/int
Float/float
Double/double
Long/long
LocalDate
LocalDateTime
-------------------------------------------

[NOTE]
Double and Float values are always passed with "." delimiter, either if you pass the query or request parameter with "," delimiter.

All parameters are parsed case-sensitive, which means, that if you have a method parameter "localDateTime" you have to map the
request-parameter accordingly, e.g. /foo/{localDateTime}.

[NOTE]
LocalDate is parsed as ISO_LOCAL_DATE "yyyy-MM-dd", and LocalDateTime is parsed as ISO_LOCAL_DATE_TIME "yyyy-MM-ddThh:mm:ss".

The following classes can also be used directly in controller methods, but can not be used as a request or query parameter

-------------------------------------------
Form
Authentication
Session
Flash
Body
Request
-------------------------------------------

=== Special parameter

TBD

=== ETag for dynamic content

"ETag" or "entity tag" enables web application to make use of cached resources by allowing conditional requests from the client.
This is widely used for static resources like CSS or JS files.

mangoo I/O offers this functionality for dynamic content as well. To make use of an entity tag, simply add the
following method at the returning response in your controller method.

[NOTE]
If you are using a front-end HTTP server, please check the documentation on how it
handles ETag, as the popular nginx web server https://thinkingandcomputing.com/2014/09/27/enable-etag-nginx-resources-sent-gzip/[deliberately strips ETags] once gzip is applied.

[source,java]
-----------------------------
public Response index() {
    return Response.withOk().andETag();
}
-----------------------------

For more information on how ETag works, click https://en.wikipedia.org/wiki/HTTP_ETag[here].

=== Administrative URLs

mangoo I/O offers administrative URLs, which enables you to check certain application information via a web interface. The
following administrative URLs are available

-------------------------------------------
/@routes
/@config
/@cache
/@health
-------------------------------------------

[NOTE]
By default, the administrative URLs are enabled in dev mode and disabled in test and prod mode. You
can enable each administrative URL by setting the appropriate configuration value in your application.yaml.
see <<Configuration options>> for more information on this.

==== /@routes

Displays a list of all configured routes and their corresponding controllers and methods.

==== /@config

Displays a list of all configured properties and their corresponding values.

[WARNING]
For security reasons the properties "application.secret", "smtp.username" and "smtp.password" is not available via the @config route.

==== /@cache

Displays a list of cache statistics including cache hits, cache misses, etc.

==== /@health

Displays a simple health check by returning "alive".

== Form handling

To access a form submitted to a controller class, you can simply pass
the mangoo I/O Form class. Here is an example of how this might look
like

[source,java]
----------------------------------
public Response index(Form form) {
    ...
}

----------------------------------

The Form class offers you convenient methods for accessing form values from you template.

[source,java]
----------------------------------
public Response index(Form form) {
    File file = form.getFile();
    List<File> = form.getFiles();
    String firstname = form.get("firstname");
    ...
}

----------------------------------

[NOTE]
The Form class is only available if the request is mapped as a POST or PUT method.

The Form class is automatically available in the template so you don't
have to pass the class to your template.

=== Form validation

Lets image you have the following form in a template

[source,html]
------------------------------------------
<form method="/save" method="post">
    <input type="text" name="firstname" />
    <input type="text" name="lastname" />
    <input type="text" name="email" />
</form>
------------------------------------------

No lets imagine that you want to validate, that the firstname and
lastname from the request is not empty. mangoo I/O offers some convenient
functions to validate the submitted form values.

[source,java]
---------------------------------
public Response form(Form form) {
    form.validation().email("email");
    form.validation().required("firstname");
    form.validation().required("lastname");

    if (!form.validation().hasErrors()) {
        //Handle form
    } else {
        //Do nothing
    }

    ...
}
---------------------------------

With the form class you can check if a field exists, check an eMail
address, etc. The hasErrors() method shows you if the form is valid and
can be handled or not.

mangoo I/O supports the following validations out of the box

* Required
* Minimum
* Maximum
* Match (case-insensitive)
* Exact match (case-sensitive)
* E-Mail
* IPv4
* IPv6
* Range
* Regular expression

=== Showing error messages in a template

To show an error in a template, simply check for an error on a spcific field

[source,html]
-----------------------------------------
<#if form.hasError("myField")> ... </#if>
-----------------------------------------

This is useful if you want to change the CSS style or display an error
message when the submitted form is invalid.

To display a form specific error you can use the error method on a form field

[source,html]
-----------------------
${form.error("myField)}
-----------------------

This will display e.g.

--------------------------
Firstname can not be blank
--------------------------

The error messages are defined in your messages.properties file (or for
each language). There are some default error messages, but they can be
overwritten with custom error messages. If you overwrite a
validation message you have to use the appropriate prefix

--------------------------------------------------------
validation.required={0} is required
validation.min={0} must be at least {1} characters
validation.max={0} can be max {1} characters
validation.exactMatch={0} must exactly match {1}
validation.match={0} must match {1}
validation.email={0} must be a valid eMail address
validation.ipv4={0} must be a valid IPv4 address
validation.ipv6={0} must be a valid IPv6 address
validation.range={0} must be between {1} and {2} characters
validation.url={0} must be a valid URL
validation.regex={0} is invalid
--------------------------------------------------------

The prefix follows the field type (email, required, match, etc.) for the
message.

=== CSRF Protection

mangoo I/O allows you to retrieve an authenticity token for protection
against https://de.wikipedia.org/wiki/Cross-Site-Request-Forgery[CSRF].
You can either obtain a prefilled hidden input field or the token itself.

To get the prefilled hidden input field, use the following tag in your
template

[source,html]
--------------------
<@authenticityForm/>
--------------------

To get the token, use the following tag in your template

[source,html]
---------------------
<@authenticityToken/>
---------------------

If you use either the form or the token you might want to check the
token in your controller. mangoo I/O offers a filter for checking the
correctness of the token. Just add the following filter to your
controller class or method.

[source,java]
------------------------------------
FilterWith(AuthenticityFilter.class)
------------------------------------

If the token is invalid the request will be redirected to a default
403 Forbidden page.

== Working with JSON

mangoo I/O uses https://github.com/boonproject/boon[boon] for parsing JSON. boon is a
http://rick-hightower.blogspot.de/2014/01/boon-json-in-five-minutes-faster-json.htm[very
fast] JSON handler with its main focus on serializing and deserializing of objects.

=== JSON output

Consider for example the following POJO.

[source,java]
---------------------------------------------------------------
package models;

public class Person {
    private String firstname;
    private String lastname;
    private int age;

    public Person(String firstname, String lastname, int age) {
        this.firstname = firstname;
        this.lastname = lastname;
        this.age = age;
    }

    public String getFirstname() {
        return firstname;
    }

   public String getLastname() {
       return lastname;
    }

    public int getAge() {
        return age;
    }
}
---------------------------------------------------------------

To create a new person object and send it as a response you can simply can do this in
a controller

[source,java]
----------------------------------------------------------
package controllers;

import io.mangoo.routing.Response;
import models.Person;

public class JsonController {
    public Response render() {
        Person person = new Person("Peter", "Parker", 24);
        return Response.withOk().andJsonBody(person);
    }
}
----------------------------------------------------------

The output of the response will look as follows

[source,json]
--------------------------
{
    "firstname" : "Peter",
    "lastname" : "Parker",
    "age" : 24
}
--------------------------

=== JSON input

To retrieve JSON which is send to your mangoo I/O application you have three options:
automatic object serialization, generic object convertion or working with the raw JSON
string.

==== Automatic object convertion

Consider the person class from above and the following JSON send to
mangoo I/O

[source,json]
---------------------------
{
    "firstname" : "Petyr",
    "lastname" : "Baelish",
    "age" : 42
}
---------------------------

To handle this JSON with automatic object convertion you can simply do this
in a controller.

[source,java]
-----------------------------------------------
package controllers;

import io.mangoo.routing.Response;
import models.Person;

public class JsonController {
    public Response parse(Person person) {
        // TODO Do something with person object
        ...
    }
}
-----------------------------------------------

You just pass the object you want to convert from the JSON request and
mangoo I/O automatically makes the serialization to your POJO, making it available
in your controller.

==== Generic object convertion

If you don't have a POJO and you want to retrieve the JSON content,
mangoo I/O offers you a generic way of retrieving the content through
the object body of a request to a Map<String, Object>.

[source,java]
--------------------------------------------
package controllers;

import io.mangoo.routing.Response;

public class MyController {
    public Response parse(Body body) {
        Map<String, Object> myjson = body.asJSON();
        String foo = json.get("firstname");
    }
}
--------------------------------------------

==== Handle raw JSON string

If you don't want mangoo I/O to automatically convert a JSON input you
can also work with the raw JSON string. The body object contains the raw
values of a request. Here is an example

[source,java]
-----------------------------------------
package controllers;

import io.mangoo.routing.Response;

public class MyController {
    public Response parse(Body body) {
        String content = body.asString();
        ...
    }
}
-----------------------------------------

== Filters

Filters are a way of executing code before each controller or each
method is executed. To execute a filter before a controller or method,
you can use the @FilterWith annotation. In fact, this is the only annotation
that comes from the mangoo I/O framework directly.

[source,java]
---------------------------
@FilterWith(MyFilter.class)
---------------------------

There are two types of filters in mangoo I/O: Controller/Method filters
and a global filter.

=== Controller or method filter

As mentioned, a filter can be added to a controller class or method. If
added to a controller class the filter will be exectued on every method
in the class. If added to a method, the filter will only be executed on
that method.

[source,java]
----------------------------------------------------------
package controllers;

import io.mangoo.annotations.FilterWith;
import io.mangoo.filters.AuthenticityFilter;
import io.mangoo.routing.Response;

@FilterWith(MyFilter.class)
public class MyController {

    public Response token() {
        return Response.withOk().andContent("foo", "bar");
    }

    @FilterWith(AuthenticityFilter.class)
    public Response valid() {
        return Response.withOk().andContent("foo", "bar");
    }
}
----------------------------------------------------------

On the above example, the Filter MyFilter will be executed when the
token() and the valid() method is called. The Filter AuthenticityFilter will
also be called, when the valid() method is called.

You can assign multiple filters to a controller or a method.

[source,java]
----------------------------------------------------------
@FilterWith({"MyFirstFilter.class, MySecondFilter.class"})
----------------------------------------------------------

They are executed in order.

==== Creating a filter

A controller or method filter must implement the MangooFilter
interface.

[source,java]
---------------------------------------------------------
package mangoo.io.filters;

import io.mangoo.interfaces.MangooControllerFilter;
import io.mangoo.routing.bindings.Exchange;

public class MyFilter implements MangooFilter {

    @Override
    public Response filter(Request request, Response response) {
        //Do nothing for now
        return response;
    }
}
---------------------------------------------------------

The main method of a filter is the filter method, which receives the
exchange class from mangoo I/O. This class gives you a handy way of manipulating
the request/response cycle. A long with other convenient methods, the
exchange class enables you access to the Unterdow HttpServerExchange
class.

Here is an example of the AuthenticityFilter which is used for the CSRF checks,
showing you how to interact with the Undertow request/response cycle.

[source,java]
-----------------------------------------------------------------------------------------------------
public class AuthenticityFilter implements MangooControllerFilter {

    @Override
    public boolean filter(Exchange exchange) {
        if (!exchange.authenticityMatches()) {
            exchange.getHttpServerExchange().setResponseCode(StatusCodes.FORBIDDEN);
            exchange.getHttpServerExchange().getResponseSender().send(Templates.DEFAULT.forbidden());

            return false;
        }

        return true;
    }
}
-----------------------------------------------------------------------------------------------------

As you can see in the example, you can change the status code, a long
with the content of the response inside a filter. The exchange.getHttpServerExchange()
offers even more method for customization.

See the http://undertow.io/undertow-docs/undertow-docs-1.2.0/index.html[Undertow documentation] for
more information on the HttpServerExchange.

One important part in a filter is the return value. If the filter method
returns true, it tells mangoo I/O to continue its executing and call
further filters. If the filter method
returns false mangoo I/O stops the execution of further filters
and controller method. One can say, that the request ends with the filter.

=== Global filter

Besides the controller class or method filter, there is a special filter
which can be executed globally. This means, that this filter is called on
every mapped request in the Routes class. This is useful if, for example, you have to
force the language for your application or if you have an application
that does not have any public content and requires authentication for
every request.

A global filter works similar to a controller or method filter, but the
filter has to implement the MangooRequestFilter interface instead.

[source,java]
------------------------------------------------------------
package filters;

import io.mangoo.interfaces.MangooRequestFilter;
import io.mangoo.routing.bindings.Exchange;

public class MyGlobalFilter implements MangooRequestFilter {

    @Override
    public execute filter(Request request, Response response) {
        //Do nothing for now
        return response;
    }
}
------------------------------------------------------------

[NOTE]
There can only be one global filter in your mangoo I/O application.

== Logging

mangoo I/O uses http://logback.qos.ch[Logback] for logging, enabling you
a variate of loggers to append to. If you are familiar with Log4j,
creating a new logger instance is trivial.

[source,java]
-------------------------------------------------------------------------
private static final Logger LOG = LoggerFactory.getLogger(MyClass.class);
-------------------------------------------------------------------------

You can configure your appenders in the logback.xml file located in
src/main/resources. By convention, there is also a special logback
configuration file for the prod mode. This file is called
logback.prod.xml and automatically used, when you are in prod mode. This file is
optional and if this file is not present, mangoo I/O will fallback to logback.xml
and further fallback to the logback settings from the logback base package.

== Caching

mangoo I/O uses https://github.com/google/guava/wiki/CachesExplained[Guava Cache] for storing and accessing values
in-memory. To use the cache in your application, simply inject the cache class.

[source,java]
--------------------
@Inject
private Cache cache;
--------------------

The cache offers some convenient functions for adding and removing values
from the cache.

Check out the https://github.com/google/guava/wiki[Guava
documentation] on how to configure the cache.

To use the cache, simply add or remove an entry by a specific key.

[source,java]
--------------------
String foo = cache.get("myvalue", String.class);
--------------------

One cool thing about the guava cache, is the option to pass a callable if the value is
not found in the cache.

[source,java]
--------------------
// If the key wasn't in the "easy to compute" group, we need to
// do things the hard way.
  cache.get("myvalue", new Callable<Value>() {
    @Override
    public Value call() throws AnyException {
      return doThingsTheHardWay(key);
    }
  });
--------------------

== Scheduling

mangoo I/O uses the http://quartz-scheduler.org[Quartz Scheduler
Framework] for creating and executing periodic tasks. To create a new
task, create a simple Pojo that implements the Job interface from
Quartz.

[source,java]
-----------------------------------------------------------------------------------------------------
package jobs;

import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

import com.google.inject.Singleton;

@Singleton
public class MyJob implements Job {

    @Override
    public void execute(final JobExecutionContext jobExecutionContext) throws JobExecutionException {
        //Do nothing for now
    }
}
-----------------------------------------------------------------------------------------------------

As this job is not scheduled or executed at all right now, you have to
tell the scheduler when to execute the task and to start the scheduler
itself. It is recommended to use the Lifecycle for scheduling tasks and
starting the scheduler.

[source,java]
----------------------------------------------------------------------------------------------------------------------------------
package conf;

import org.quartz.JobDetail;
import org.quartz.Trigger;

import jobs.InfoJob;
import io.mangoo.interfaces.MangooLifecycle;
import io.mangoo.scheduler.MangooScheduler;

import com.google.inject.Inject;
import com.google.inject.Singleton;

@Singleton
public class Lifecycle implements MangooLifecycle {

    @Inject
    private MangooScheduler mangooScheduler;

    @Override
    public void applicationStarted() {
        JobDetail jobDetail = mangooScheduler.getJobDetail(MyJob.class, "MyJobDetail", "MyJobGroup");
        Trigger trigger = mangooScheduler.getTrigger("MyJobTrigger", "15 15 15 15 * ?", "MyTriggerGroup", "MyTriggerDescription");

        mangooScheduler.schedule(jobDetail, trigger);
        mangooScheduler.start();
    }
}
----------------------------------------------------------------------------------------------------------------------------------

To schedule the previously defined class, you have to create a JobDetail
and a Trigger which you pass to the scheduler. Once that is done, you
can start the scheduler by simply calling the start method.

=== Custom Quartz Scheduler configuration

If you require a custom configuration for quartz inside mangoo I/O you
can use the application.yaml to pass any option to quartz. Simply add the configuration option with the appropriate
prefix org.quartz.

[source,yaml]
-------------------------------------
org:
  quartz:
    scheduler.instanceName=Foo
    scheduler.instanceId=Bar
-------------------------------------

Check out the
http://quartz-scheduler.org/generated/2.2.1/html/qs-all/#page/Quartz_Scheduler_Documentation_Set%2F_qs_all.1.041.html%23[Quartz
Scheudler configuration documentation] for more information.

== Sending eMails

mangoo I/O uses the mature and well documentated
https://commons.apache.org/proper/commons-email/[Apache Commons Email].
to make sending eMails as easy as possible. If you want to send an eMail via mangoo I/O you need
the Mailer object. This can be easily injected in your controller.

[source,java]
----------------------
@Inject
private Mailer mailer;
----------------------

The Mailer object offers three functions for sending emails: sending a
plain text eMail, sending a html eMail and sending a multipart eMail.
Just create an eMail object you want to send and pass it to the appropiate mailer
function. You can check the
https://commons.apache.org/proper/commons-email/userguide.html[Apache
Commons Email documentation] on how to create the eMail objects you require.

[NOTE]
You don't have to create any SMTP configuration programmatically as shown in the
Apache Commons Email documentation. This is all done via the application.yaml and passed to the Mailer class of your mangoo
I/O application, so you can set your host, port, username, password and ssl usage only once.

Here is an example of how to send a plain text message.

[source,java]
----------------------------------------------------
package mangoo.controllers;

import io.mangoo.mail.Mailer;
import org.apache.commons.mail.Email;
import org.apache.commons.mail.SimpleEmail;
import com.google.inject.Inject;

public class MailController {

    @Inject
    private Mailer mailer;

    public void mail() {
        Email email = new SimpleEmail();
        email.setFrom("user@gmail.com");
        email.setSubject("TestMail");
        email.setMsg("This is a test mail ... :-)");
        email.addTo("foo@bar.com");

        mailer.send(email);
    }
}
----------------------------------------------------

If you want an eMail with a message body that is rendered from a
template you can use the mangoo I/O TemplateEngine.

[source,java]
------------------------------------------------------------------------------------------------------------------
package mangoo.controllers;

import java.util.HashMap;
import java.util.Map;

import io.mangoo.i18n.Messages;
import io.mangoo.mail.Mailer;
import io.mangoo.routing.bindings.Flash;
import io.mangoo.routing.bindings.Session;
import io.mangoo.templating.TemplateEngine;

import org.apache.commons.mail.Email;
import org.apache.commons.mail.SimpleEmail;

import com.google.inject.Inject;

public class MailController {

    @Inject
    private Mailer mailer;

    @Inject
    private TemplateEngine templateEngine;

    @Inject
    private Messages messages;

    public void mail(Flash flash, Session session) {
        Map<String, Object> content = new HashMap<String, Object>();
        content.put("foo", "bar");

        String message = templateEngine.render(flash, session, messages, "/myPackage", "myMailTemplate", content);

        Email email = new SimpleEmail();
        email.setFrom("user@gmail.com");
        email.setSubject("TestMail");
        email.setMsg(message);
        email.addTo("foo@bar.com");

        mailer.send(email);
    }
}
------------------------------------------------------------------------------------------------------------------

== Using WebSockets

Genereal information on using WebScokets can be found
http://en.wikipedia.org/wiki/WebSocket[here]. To use WebSockets in
mangoo I/O you have to extend the MangooWebSocket class in your WebSocket controller. Extending this
class offers you the entry points for using WebSockets methods.

[source,java]
-------------------------------------------------------------------------------------------------
package controllers;

import io.undertow.websockets.core.BufferedBinaryMessage;
import io.undertow.websockets.core.BufferedTextMessage;
import io.undertow.websockets.core.CloseMessage;
import io.undertow.websockets.core.WebSocketChannel;
import io.mangoo.interfaces.MangooWebSocket;

public class WebSocketController extends MangooWebSocket {
    @Override
    protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {
        //Do nothing for now
    }

    @Override
    protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessage message) {
        //Do nothing for now
    }

    @Override
    protected void onFullPongMessage(WebSocketChannel channel, BufferedBinaryMessage message) {
        //Do nothing for now
    }

    @Override
    protected void onCloseMessage(CloseMessage closeMessage,  WebSocketChannel channel) {
        //Do nothing for now
    }
}
-------------------------------------------------------------------------------------------------

To use WebSockets on a specific request you have to map your WebSocket
Controller in the Routes class with an appropriate method.

[source,java]
-----------------------------------------------------------------------------
Router.mapWebSocket().toUrl("/websocket").onClass(WebSocketController.class);
-----------------------------------------------------------------------------

Now you can start creating an application to access your
WebScoketController at the URL "/websocket". Of course, you can have multiple
WebSocket controllers in your application, each mapped to a specific URL.

== i18n Internationalization

Translations in mangoo I/O are based on the standard Locale of Java. The
Locale is determined from each request from the Accept-Language header of
the request. If the Locale can not be determined from the request,
the default language of the application from application.yaml will be
used. If this configuration is not set, mangoo I/O will default to "en".

If you want to force the language, you simply set the Locale in a filter
- see <<Filters>> for more information on filters.

[source,java]
----------------------------------
Locale.setDefault(Locale.ENGLISH);
----------------------------------

mangoo I/O offers you a convenient way of accessing translations. To get
hold of the translations simply inject the Messages class.

[source,java]
---------------------------------------------------
package controllers;

import com.google.inject.Inject;

import io.mangoo.i18n.Messages;
import io.mangoo.routing.Response;

public class I18nController {

    @Inject
    private Messages messages;

    public Response translation() {
        messages.get("my.translation");
        messages.get("my.othertranslation", "foo");

         ...
    }
}
---------------------------------------------------

The messages class offers you two methods of retrieving translations
from the resource bundle. In this example a translation is called with
and without passing optional parameters. The corresponding translation
entries in the resource bundle would look like this

-----------------------------------------------------------------
my.translation=This is a translation
my.othertranslation=This is a translation with the paramater: {0}
-----------------------------------------------------------------

Note the {0} which will be replaced by the passed paramter "foo".

=== Translation in templates

To access translation in a template, you can us a special tag a long with the key
for your translation.

[source,html]
-------------------------
${i18n("my.translation")}
-------------------------

To pass a parameter to the translation simply append the parameter

[source,html]
-------------------------------------
${i18n("my.othertranslation", "foo")}
-------------------------------------

If no key is found in the resource bundle the template will output an
empty value.

== Sessions

With a http://en.wikipedia.org/wiki/Shared_nothing_architecture[Shared
nothing architecture] in mind mangoo I/O uses a so called client-side
session. This means, that all information for a specific user is stored
on the client-side inside a cookie. The big advantage of this concept
is, that you can scale your application very easy, because nothing
connects a specific user to a specific mangoo I/O instance. The
downside of this architecture is, that you can only stored limited data
in the cookie (around 4k of data).

To make use of the mangoo I/O session, you can just pass the Session
class into your controller method.

[source,java]
------------------------------------------------------
package controllers;

import io.mangoo.routing.Response;
import io.mangoo.routing.bindings.Session;

public class SessionController {
    public Response session(Session session) {
        session.add("foo", "this is a session value");
        return Response.withOk().andEmptyBody();
    }
}
------------------------------------------------------

The Session class offers you some convenient methods for adding, deleting
or completly erasing session data.

By default the session cookie has a lifespan of one day (86400 seconds). This, a long
with the name of the cookie, can be configure using the following
properties in the application.yaml

[source,yaml]
---------------------------------------
cookie:
  expires  : 86400
---------------------------------------

=== Session data in templates

To access the Session values, simply call the appropriate key in your
template.

[source,html]
--------------
${session.foo}
--------------

The Session class is automatically available in the template so you
don't have to pass the class to the template via a controller.

=== Session encryption

By default the values in the client-side cookie are signed with the
application secret using SHA2(SHA-512), making manipulation of the
values very difficult. The security of the client-side cookie can be further
increased by using AES encryption. To activate cookie encryption of the
session cookie, set the following property in your application.yaml

[source,yaml]
----------------------
cookie:
  encryption  : true
----------------------

The encryption strength is based on the length of your
application.secret configured in your application.yaml. If your
application.secret is more or equal than 32 characters, AES-256 will be
used. If you secret is more or equal than 24 characters, AES-192 will be
used. If your secret is more or equal than 16 characters AES-128 will
be used. The mangoo I/O framework will automatically determine and use
the strongest key possible.

== Flash

Specially when working with forms it is useful to pass certain
informations (e.g. error- or success messages) to the next request. To
do this in a stateless environment, mangoo I/O uses the Flash class. This
is basically the same mechanism as a session, but all informations
are stored in a special flash cookie which is disposed once the request is finished.

[source,java]
-------------------------------------------
package controllers;

import io.mangoo.routing.Response;
import io.mangoo.routing.bindings.Flash;

public class FlashController {
    public Response flash(Flash flash) {
        flash.success("this is a success");
        flash.warning("this is a warning");
        flash.error("this is an error");
        flash.add("foo", "bar");

       return Response.withRedirect("/");
    }
}
-------------------------------------------

The Flash class has three convenient methods for the commonly used
scenarios: success, warning and error. This methods will automatically
create a key "success", "warning" or "error" in the flash class. Besides
that, you can pass custom values to the flash class.

=== Flash in templates

To access the flash values, simply call the appropriate key in your
template.

[source,html]
----------------
${flash.success}
${flash.warning}
${flash.error}
${flash.foo}
----------------

The Flash class is automatically available in the template so you don't
have to pass the class to the template via a controller.

== Authentication

mangoo I/O comes with two authentication implementations out of the box: HTTP Basic
authentication and custom authentication where you have a custom login
and authentication process ready to use.

=== Basic authentication

The HTTP Basic authentication in mangoo I/O uses a predefined filter:
BasicAuthenticationFilter.class. So the first step to enable Basic
authentication would be to have a annotated controller or method.

[source,java]
-----------------------------------------------
package controllers;

import io.mangoo.annotations.FilterWith;
import io.mangoo.authentication.Authentication;
import io.mangoo.filters.AuthenticationFilter;
import io.mangoo.routing.Response;

public class AuthenticationController {

    @FilterWith(AuthenticationFilter.class)
    public Response secret() {
        return Response.withOk();
    }
}
-----------------------------------------------

To validate credentials passed from the client you need some place to do
this. Therefore you have to bind the authentication process via the Google
Guice configuration in your Module class.

[source,java]
--------------------------------------------------------------------------------------------
package conf;

import io.mangoo.interfaces.MangooAuthenticator;

import com.google.inject.AbstractModule;
import com.google.inject.Singleton;

@Singleton
public class Module extends AbstractModule {
    @Override
    protected void configure() {
        bind(MangooAuthenticator.class).toInstance(
                (username, password) -> ("foo").equals(username) && ("bar").equals(password)
        );
    }
}
--------------------------------------------------------------------------------------------

In this example a Java 8 lambda expression is used to validate the
passed credentials. Of coures, an instance of the MangooAuthenticator
can be passed in any other way. Just make sure you implement the
MangooAuthenticator interface and bind your implementation via the
Module class.

=== Custom authentication

mangoo I/O supports you when a custom registration with a custom login
process is required. Although mangoo I/O does not store any credentials
or user data for you, it gives you some handy functions to make
handling of authentication as easy as possible.

mangoo I/O offers the Authentication class which can be simply injected
into a controller class.

[source,java]
--------------------------------------
@Inject
private Authentication authentication;
--------------------------------------

The authentication uses http://de.wikipedia.org/wiki/Bcrypt[BCrypt]
provided by http://www.mindrot.org/projects/jBCrypt[jBCrypt] for
password hashing. This means, that you don't have to store a salt along
with the user data, just the hashed password. This also means, that you have
to hash the user password with the provided function in the authentication class
and store this hash value along with your user data. This hashed value can be created with
the following method

[source,java]
----------------------------------
getHashedPassword(String password)
----------------------------------

After you create the hash of the cleartext password of your user, you
have to store it with your user data. mangoo I/O does not do that for you.

The Authentication class offers convenient functions to perform
authentication. The main methods are

[source,java]
------------------------------------------
getAuthenticatedUser()
authenticate(String password, String hash)
login(String username, boolean remember)
logout()
------------------------------------------

To perform a check, if a user is authenticated mangoo I/O offers a
predefined filter ready to use on controller classes or methods.

[source,java]
---------------------------------------
@FilterWith(AuthenticationFilter.class)
---------------------------------------

Check the JavaDoc of the Authentication class to get more information on
how the methods work. Also check the custom configuration options for
the Authentication class in link:#c-configuration-options[C.
Configuration options]. All options with the prefix "auth" configure
custom Authentication.

== Handling static files and assets

There is often a scenario where you have to serve static files or assets
to the client. Take the robots.txt or CSS and JS files for example.
mangoo I/O offers a convenient way of doing this. The src/main/resources
package must contain a folder called /files which is the entry point for
serving static files and assets. To serve a static file or asset you
have to create a mapping in the Routes class. You have to decide
if you want to serve a static file (a so called ResourceFile) or a
complete folder with all its sub-files and sub-folders (a so called
ResourcePath)

[source,java]
----------------------------------------------
Router.mapResourceFile().toUrl("/robots.txt");
Router.mapResourcePath().toUrl("/assets/");
----------------------------------------------

The above example maps a resource file located in
src/main/resources/files/robots.txt to the request URI /robots.txt and a
resource path located in src/main/resources/files/assets/ to all
requests with the prefix /assets/ in the URI. For example

-------------------------------------
http://mydomain.com/robots.txt
http://mydomain.com/assets/mycss.css
-------------------------------------

=== On-the-fly asset minification

When in dev mode, mangoo I/O offers you the ability to minify CSS and JS
resources on-the-fly, giving a front-end developer the opportunity to
work in the raw CSS and JS files and have the minified version linked in
the default template of your application. Thus, there is no need for
extra minification or post processing before deployment to a production environment.

By default minification of CSS and JS resources is disabled and has to
be enable with the following options

[source,yaml]
----------------------
application:
    minify:
          js     : true
          css    : true
----------------------

By convention, if on-the-fly minification is activated mangoo I/O will check
for changes in all files ending with .css or .js that have no "min" in their
file name and are located in the following folder

--------------------------------
/src/main/resources/files/assets
--------------------------------

Once a file is changed, mangoo I/O will automatically minify the file.
Already minified files, for example jquery.min.js will not be minified
again. The on-the-fly minification will create a file with the same
name, ending with .min.css or .min.js.

Of course you can configure the folder for the CSS and JS files in your
application. See <<Configuration options>> for more
information about this.

[NOTE]
There is also an option on automatically GZIP your Assets.

== Testing

mangoo I/O ships with convenient tools for testing your application.
Please note, that these utilities are not part of the core and come with
a additional dependency. This is mainly because you want to set the scope of
this dependency set to "test" in your maven configuration.

[source,maven]
--------------------------------------------------------
<dependency>
    <groupId>io.mangoo</groupId>
    <artifactId>mangooio-test-utilities</artifactId>
    <version>1.0.0</version>
    <scope>test</scope>
</dependency>
--------------------------------------------------------

There are two ways of executing unit tests with mangoo I/O. Simple unit
tests which start the framework, execute the unit test and stop
framework again and a TestSuite which starts the framework once, executes all
tests and stops the framework after all tests are finished. Both ways
have there advantages and disadvantages. When using simple unit tests
the tests can be executed separately, a TestSuite will always run all
tests. When using a TestSuite however, the framework needs to be started
only once needing less time to execute all tests.

=== Simple unit testing

As mangoo I/O is a web framework, the main focus of testing an
application relies on testing requests and responses as well as frontend
testing. For request and response tests, mangoo I/O offers the
MangooRequest class with has a fluent API for executing HTTP requests.
Here is an example for a unit test.

[source,java]
----------------------------------------------------------------------------
package mangoo.controllers;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import io.undertow.util.StatusCodes;
import io.mangoo.testing.MangooRequest;
import io.mangoo.testing.MangooResponse;

import org.junit.Test;

public class ApplicationControllerTest extends MangooUnit {

    @Test
    public void indexTest() {
        MangooResponse response = MangooRequest.get("/").execute();

        assertNotNull(response);
        assertEquals("text/html; charset=UTF-8", response.getContentType());
        assertEquals(StatusCodes.OK, response.getStatusCode());
    }
----------------------------------------------------------------------------

Please note, that you have to extend MangooUnit if you are not using the TestSuite.
Otherwise the framework will not start before each unit test and your tests will fail.

=== Testing with a TestSuite

Using a TestSuite is mostly suitable for situation where you want to
startup for e.g. a database or other processes only once and execute
your tests on that instance. For using a TestSuite you need an
entry-point for the execution which extends the MangooRunner interface.

[source,java]
---------------------------------------------
package mangoo;

import io.mangoo.testing.MangooRunner;

public class TestSuite extends MangooRunner {
}
---------------------------------------------

This just needs to be an empty class for telling maven to use this Suite
when tests are executed. Additionally Add the following plugin to your pom.xml to
make Maven aware of your TestSuite class.

[source,maven]
--------------------------------------------------
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.18.1</version>
    <configuration>
        <includes>
            <include>**/*TestSuite.java</include>
        </includes>
    </configuration>
</plugin>
--------------------------------------------------

By convention, the TestSuite will execute all tests that ends with
"*Test" in their class name. As for the unit tests, you don't have to
extend or implement anything additional. If you want to execute
FluentLenium tests in a TestSuite you have to use the native support for FluentLenium in JUnit
as the TestSuite does not wrap around FluentLenium in comparison to
MangooUnit for simple unit tests.

See the https://github.com/FluentLenium/FluentLeniuhttps://github.com/FluentLenium/FluentLenium[FluentLenium documentation] on how to use FluentLenium standalone.

=== Frontend testing

For frontend testing mangoo I/O uses
https://github.com/FluentLenium/FluentLenium[FluentLenium]. Here is an example of how a FluentLenium test might look
like.

[source,java]
------------------------------------------------------------------
package mangoo.controllers;

import static org.junit.Assert.assertTrue;
import io.mangoo.testing.MangooUnit;

import org.junit.Test;

public class FluentTest extends MangooFluent {

    @Test
    public void title_of_bing_should_contain_search_query_name() {
        goTo("http://www.bing.com");
        fill("#sb_form_q").with("FluentLenium");
        submit("#sb_form_go");
        assertTrue(title().contains("FluentLenium"));
    }
}
------------------------------------------------------------------

== Deployment

The full stack architecture of mangoo I/O offers the ability to create a
single JAR file containing all required dependencies, ready to start the
built-in Undertow server.

To create a deployable JAR file, execute the following command

[source,bash]
-----------------
mvn clean package
-----------------

The https://maven.apache.org/plugins/maven-shade-plugin/[Maven Shade
Plugin] will generate the JAR file, which you can find in the target
directory once the maven build is complete. By default, the JAR file
will be named "mangooioapp.jar" (if you have create your mangoo I/O project
via the archetype). You can change the name in your pom.xml file in
the Shade Plugin configuration.

[source,maven]
----------------------------------
<finalName>mangooioapp</finalName>
----------------------------------

After you have deployed the jar to your production environment, you can
start the application by executing the following command

[source,bash]
-----------------
java -jar app.jar
-----------------

This will start mangoo I/O in production mode, using the default
configuration from your application.yaml

[NOTE]
Also Undertow is production-ready, it is recommended to use a front-end HTTP
server such as nginx or Apache to leverage an easy configuration for
load-balancing, SSL termination, etc.

=== Debian init.d script

The following script is an example of how to start, stop and restart a
mangoo I/O application as a deamon on debian.

[source,bash]
---------------------------------------------------------------------------------------------------------------------------------------
#!/bin/sh
### BEGIN INIT INFO
# Provides:          mangoo I/O
# Required-Start:    $syslog
# Required-Stop:     $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/Stop mangoo I/O Application
### END INIT INFO

### CONFIGURATION ###

NAME=MyApplication
APPLICATION_PATH=/path/to/application/app.jar

XMX=128m
XMS=64m

DAEMON=/usr/bin/java

chown www-data:www-data /path/to/application/app.jar
### CONFIGURATION ###

PIDFILE=/var/run/$NAME.pid
USER=www-data

case "$1" in
  start)
        echo -n "Starting "$NAME" ..."
        start-stop-daemon --start --quiet --make-pidfile --pidfile $PIDFILE --chuid ${USER} --background --exec $DAEMON -- $DAEMON_OPTS
        RETVAL=$?
        if [ $RETVAL -eq 0 ]; then
                echo " Success"
            else
                echo " Failed"
        fi
        ;;
  stop)
        echo -n "Stopping "$NAME" ..."
        start-stop-daemon --stop --quiet --oknodo --pidfile $PIDFILE
        RETVAL=$?
        if [ $RETVAL -eq 0 ]; then
                echo " Success"
            else
                echo " Failed"
        fi
        rm -f $PIDFILE
        ;;
  restart)
        echo -n "Stopping "$NAME" ..."
        start-stop-daemon --stop --quiet --oknodo --retry 30 --pidfile $PIDFILE
        RETVAL=$?
        if [ $RETVAL -eq 0 ]; then
                echo " Success"
            else
                echo " Failed"
        fi
        rm -f $PIDFILE
        echo -n "Starting "$NAME" ..."
        start-stop-daemon --start --quiet --make-pidfile --pidfile $PIDFILE --chuid ${USER} --background --exec $DAEMON -- $DAEMON_OPTS
        RETVAL=$?
        if [ $RETVAL -eq 0 ]; then
                echo " Success"
            else
                echo " Failed"
        fi
        ;;
   status)
        if [ -f $PIDFILE ]; then
                echo $NAME" is running"
        else
                echo $NAME" is NOT not running"
        fi
        ;;
*)
        echo "Usage: "$1" {start|stop|restart|status}"
        exit 1
esac

exit 0
---------------------------------------------------------------------------------------------------------------------------------------

Place this script in /etc/init.d and use it as follows

[source,bash]
------------------------------------------------
/etc/init.d/MyScript (start|stop|restart|status)
------------------------------------------------

If you are using Debian, than http://supervisord.org/[Supervisord] might be an alternative to the init.d Script.

[appendix]
== How to contribute

As mangoo I/O is an open source project hosted on
https://github.com/svenkubiak/mangooio[GitHub], you are welcome to
contribute to the Framework. Pull requests containing bug fixes or
further enhancements are more than welcome. Please make sure, that your
code is well tested and documented.

If you want to stay up to date on the latest news for mangoo I/O you can
follow the Twitter account https://twitter.com/mangoo_io[@mangoo_io].

If you find a bug, please open an issue. If you find a security flaw,
please send an eMail to webmaster@mangoo.io so it can be fixed ASAP.

[appendix]
== Extensions

Extensions are a way of adding features to mangoo I/O which are not part
of the core. The most popular example of an extension is persistence.
Here you'll find a list of existing extensions.

MongoDB Extension

* https://github.com/svenkubiak/mangooio-mongodb-extension

Hibernate Extension

* https://github.com/svenkubiak/mangooio-hibernate-extension

If you have created and extension and want it to be listed here, just
add your extension to the above list by editing the documentation.md
file and create a pull request on the GitHub repository. You can find the documentation file in mangooio-core at
https://github.com/svenkubiak/mangooio/tree/master/mangooio-core/src/main/site[/src/main/site/documentation.md].

[appendix]
== Configuration options

This is an overview of the configuration options for the
application.yaml and their default values, if the properties are not configured
in the application.yaml file.

|=======================================================================
|*Optione name* |*Description* |*Default value* |*Note*
|application.secret |The application secret |Random value |Must be at
least 16 characters or mangoo I/O won't start

|application.name |The name of the application |mangooio|

|application.language |The default language of the application |en |Used
as a fallback value for Locale

|application.minify.js |Wether to minify javascript assets or not |false
|Only used in dev mode

|application.minify.jsfolder |The folder containing js files
|/src/main/resources/files/assets/js |Only used in dev mode

|application.minify.gzipjs |Whether to GZIP JS files or not
|false |Only used in dev mode

|application.minify.css |Wether to minify stylesheet assets or not
|false |Only used in dev mode

|application.minify.cssfolder |The folder containing css files
|/src/main/resources/files/assets/css |Only used in dev mode

|application.minify.gzipcss |Whether to GZIP CSS files or not
|false |Only used in dev mode

|application.host |The address the undertow server is running on
|127.0.0.1 |In 99% of all cases, this is the localhost

|application.port |The port the undertow server is listening on |8080|

|application.admin.health |Enable or disable administrative /@health url |false|

|application.admin.routes |Enable or disable administrative /@routes url |false|

|application.admin.config |Enable or disable administrative /@config url |false|

|application.admin.cache |Enable or disable administrative /@cache url |false|

|cookie.name |The name of the session cookie |$application.name-MANGOOIO-SESSION|

|cookie.expires |The time in seconds when the session expires |86400|

|cookie.encrypt |Whether to encrypt the session cookie or not |false|

|cookie.secure |Whether to set the secure flag for the session cookie or not |false|

|cache.maxsize |The maximum number of elements in the cache |5000|

|cache.expires |Duration in seconds after which an element is removed from the cache if it is not accessed.|3600|

|smtp.host |The host of the SMTP server |127.0.0.1|

|smtp.port |The port of the SMTP server |25|

|smtp.username |Username for authentication against the SMTP server
| |Only required when using SMTP authentication

|smtp.password |Password for authentication against the SMTP server
| |Only required when using SMTP authentication

|smtp.ssl |Whether to use SSL for connecting to the SMTP |false|

|auth.cookie.name |The name of the authentication cookie
|$application.name-MANGOO-AUTH|

|auth.cookie.expire |The time in seconds how long the user stays logged
in even is the browser is closed |3600|

|auth.cookie.encrypt |Whether to encrypt the authentication cookie or
not |false|

|auth.cookie.secure |Whether to set the secure flag for the auth cookie or not |false|

|auth.login.redirect |The URL a user is redirected when not logged in
| |

|=======================================================================
